<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>M√¥ ph·ªèng ƒê·∫°o h√†m & Ti·∫øp tuy·∫øn</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- MathJax (hi·ªÉn th·ªã c√¥ng th·ª©c) -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- Marked (render Markdown t·ª´ AI) -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #1f2937; }
    ::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

    .slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: #4b5563;
      outline: none;
      opacity: 0.7;
      transition: opacity .2s;
      border-radius: 3px;
    }
    .slider-thumb:hover { opacity: 1; }
    .slider-thumb::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #eab308;
      cursor: pointer;
      border-radius: 50%;
    }

    /* Markdown styles cho panel AI */
    .prose h3 {
      font-size: 1.1rem;
      font-weight: bold;
      color: #facc15;
      margin-top: 0.5rem;
    }
    .prose p {
      margin-bottom: 0.5rem;
      color: #e5e7eb;
      font-size: 0.95rem;
    }
    .prose ul {
      list-style-type: disc;
      padding-left: 1.2rem;
      margin-bottom: 0.5rem;
    }
    .prose strong { color: #fde047; }

    /* B·∫£ng hi·ªÉn th·ªã c√¥ng th·ª©c */
    .math-container {
      background: linear-gradient(180deg, rgba(31,41,55,0.9) 0%, rgba(17,24,39,0.95) 100%);
      border: 1px solid rgba(75,85,99,0.5);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }
  </style>

  <!-- Import map cho THREE -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <!-- Left Control Panel -->
  <div
    class="absolute top-4 left-4 w-80 bg-gray-900/90 text-white p-6 rounded-xl shadow-2xl backdrop-blur-sm border border-gray-700 z-10 max-h-[90vh] overflow-y-auto">
    <h1 class="text-xl font-bold mb-4 text-yellow-400 tracking-tight">ƒê·∫°o h√†m &amp; Ti·∫øp tuy·∫øn</h1>

    <!-- B·∫£ng hi·ªÉn th·ªã c√¥ng th·ª©c -->
    <div class="math-container rounded-lg p-4 mb-6">
      <!-- H√†m s·ªë -->
      <div class="text-gray-400 text-[10px] uppercase tracking-widest font-semibold mb-1">
        H√†m s·ªë g·ªëc (Parabol)
      </div>
      <div
        id="func-display"
        class="text-lg text-center text-blue-300 mb-4 min-h-[2rem] flex items-center justify-center">
        \[ f(x) = 0.5x^2 \]
      </div>

      <!-- Gi√° tr·ªã ƒë·∫°o h√†m -->
      <div class="border-t border-gray-700 pt-3">
        <div class="flex justify-between items-baseline mb-1">
          <span class="text-gray-400 text-[10px] uppercase tracking-widest font-semibold">
            ƒê·∫°o h√†m t·∫°i \(x_0\)
          </span>
          <span class="text-xs text-yellow-500 italic">H·ªá s·ªë g√≥c</span>
        </div>
        <div
          id="deriv-display"
          class="text-xl text-center text-yellow-300 font-bold mb-4 min-h-[2rem] flex items-center justify-center">
          \[ f'(2.0) = 2.00 \]
        </div>
      </div>

      <!-- Ph∆∞∆°ng tr√¨nh ti·∫øp tuy·∫øn -->
      <div class="border-t border-gray-700 pt-3">
        <div class="text-gray-400 text-[10px] uppercase tracking-widest font-semibold mb-1">
          Ph∆∞∆°ng tr√¨nh ti·∫øp tuy·∫øn
        </div>
        <div
          id="tangent-eqn-display"
          class="text-base text-center text-white min-h-[2rem] flex items-center justify-center">
          \[ y = 2x - 2 \]
        </div>
      </div>
    </div>

    <!-- H·ªá s·ªë a -->
    <div class="mb-5">
      <div class="flex justify-between mb-1">
        <label class="text-sm font-medium text-gray-300">ƒê·ªô cong (a)</label>
        <span id="val-a" class="text-sm font-bold text-blue-400">0.5</span>
      </div>
      <input
        type="range"
        min="-2"
        max="2"
        step="0.1"
        value="0.5"
        class="slider-thumb"
        id="slider-a"
        style="background:#1e3a8a;">
    </div>

    <!-- V·ªã tr√≠ x0 -->
    <div class="mb-6">
      <div class="flex justify-between mb-1">
        <label class="text-sm font-medium text-gray-300">ƒêi·ªÉm x√©t \( x_0 \)</label>
        <span id="val-x0" class="text-sm font-bold text-yellow-400">2.0</span>
      </div>
      <input
        type="range"
        min="-5"
        max="5"
        step="0.1"
        value="2"
        class="slider-thumb"
        id="slider-x0">
    </div>

    <!-- Khu AI -->
    <div class="mb-6 pt-6 border-t border-gray-700">
      <h2 class="text-lg font-bold text-yellow-400 mb-2 flex items-center gap-2">
        <span class="text-xl">‚ú®</span> Gi·∫£i th√≠ch ƒê·∫°o h√†m
      </h2>
      <p class="text-xs text-gray-400 mb-3">
        H·ªèi AI v·ªÅ √Ω nghƒ©a c·ªßa ƒë·ªô d·ªëc t·∫°i ƒëi·ªÉm n√†y.
      </p>
      <button
        id="btn-analyze"
        class="w-full py-2 px-4 bg-yellow-600 hover:bg-yellow-500 text-white rounded transition duration-200 shadow-lg flex items-center justify-center gap-2 font-medium">
        <span id="analyze-icon">üéì</span> Gi·∫£ng b√†i cho t√¥i
      </button>
    </div>

    <!-- N√∫t reset -->
    <button
      id="btn-reset"
      class="w-full py-2 px-4 bg-gray-700 hover:bg-gray-600 text-white rounded transition duration-200 flex items-center justify-center gap-2 border border-gray-600 text-sm">
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
        <path fill-rule="evenodd"
          d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z" />
        <path
          d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z" />
      </svg>
      ƒê·∫∑t l·∫°i
    </button>
  </div>

  <!-- Panel B√†i gi·∫£ng AI b√™n ph·∫£i -->
  <div
    id="ai-panel"
    class="absolute top-4 right-4 w-80 bg-gray-900/95 text-white p-6 rounded-xl shadow-2xl backdrop-blur-md border border-yellow-500/50 z-10 hidden transform transition-all duration-300 translate-x-10 opacity-0">
    <div class="flex justify-between items-start mb-4">
      <h2 class="text-lg font-bold text-yellow-300">B√†i gi·∫£ng AI</h2>
      <button id="btn-close-ai" class="text-gray-400 hover:text-white">‚úï</button>
    </div>
    <div id="ai-content" class="prose text-sm max-h-[70vh] overflow-y-auto">
      <!-- N·ªôi dung AI -->
    </div>
  </div>

  <!-- 3D Canvas -->
  <div id="canvas-container"></div>

  <!-- TO√ÄN B·ªò LOGIC: THREE + G·ªåI APPS SCRIPT -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // URL Web App Apps Script (b·∫£n /exec)
    const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycby1D2gp14vsvs67ZgQaJJk_q2iqqLTzJfXSm0YZRYnexucwZpNUe2bn2Ag9vyn5whGF/exec"; 

    // --- GLOBAL VARIABLES ---
    let scene, camera, renderer, controls;
    let curveLine, tangentMesh, pointMesh;
    let gridHelper;

    let params = {
      a: 0.5,   // H·ªá s·ªë trong y = ax^2
      x0: 2.0   // Ho√†nh ƒë·ªô ti·∫øp ƒëi·ªÉm
    };

    // DOM elements
    const sliderA = document.getElementById('slider-a');
    const sliderX0 = document.getElementById('slider-x0');
    const displayA = document.getElementById('val-a');
    const displayX0 = document.getElementById('val-x0');

    const funcDisplay = document.getElementById('func-display');
    const derivDisplay = document.getElementById('deriv-display');
    const tangentEqnDisplay = document.getElementById('tangent-eqn-display');

    const btnReset = document.getElementById('btn-reset');

    const btnAnalyze = document.getElementById('btn-analyze');
    const aiPanel = document.getElementById('ai-panel');
    const aiContent = document.getElementById('ai-content');
    const btnCloseAi = document.getElementById('btn-close-ai');
    const analyzeIcon = document.getElementById('analyze-icon');

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111827);
      scene.fog = new THREE.Fog(0x111827, 20, 60);

      // Camera
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(15, 15, 25);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      // Grid
      gridHelper = new THREE.GridHelper(40, 40, 0x444444, 0x222222);
      scene.add(gridHelper);

      addAxes();
      createCurve();
      createTangentObjects();

      // Events
      window.addEventListener('resize', onWindowResize);
      sliderA.addEventListener('input', updateGraph);
      sliderX0.addEventListener('input', updateGraph);
      btnReset.addEventListener('click', resetGraph);
      btnAnalyze.addEventListener('click', handleAnalyzeClick);
      btnCloseAi.addEventListener('click', closeAiPanel);

      animate();
    }

    function addAxes() {
      const axesGroup = new THREE.Group();

      const xAxisGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-20, 0, 0),
        new THREE.Vector3(20, 0, 0)
      ]);
      const xAxisMat = new THREE.LineBasicMaterial({ color: 0xff4444 });
      axesGroup.add(new THREE.Line(xAxisGeo, xAxisMat));

      const yAxisGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, -20, 0),
        new THREE.Vector3(0, 20, 0)
      ]);
      const yAxisMat = new THREE.LineBasicMaterial({ color: 0x44ff44 });
      axesGroup.add(new THREE.Line(yAxisGeo, yAxisMat));

      scene.add(axesGroup);

      createLabel('x', 21, 0, 0, 'red');
      createLabel('y', 0, 21, 0, 'green');
    }

    function createCurve() {
      const points = [];
      const divisions = 200;

      for (let i = 0; i <= divisions; i++) {
        points.push(new THREE.Vector3(0, 0, 0));
      }

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0x3b82f6 });
      curveLine = new THREE.Line(geometry, material);
      scene.add(curveLine);
    }

    function createTangentObjects() {
      const geometry = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
      const material = new THREE.MeshPhongMaterial({
        color: 0xfacc15,
        shininess: 100
      });
      tangentMesh = new THREE.Mesh(geometry, material);
      scene.add(tangentMesh);

      const pointGeo = new THREE.SphereGeometry(0.4, 32, 32);
      const pointMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      pointMesh = new THREE.Mesh(pointGeo, pointMat);
      scene.add(pointMesh);

      updateGraph();
    }

    function updateGraph() {
      params.a = parseFloat(sliderA.value);
      params.x0 = parseFloat(sliderX0.value);

      // C·∫≠p nh·∫≠t label
      displayA.textContent = params.a.toFixed(1);
      displayX0.textContent = params.x0.toFixed(1);

      // f(x) = ax^2
      const f = x => params.a * x * x;
      // f'(x) = 2ax
      const slope = 2 * params.a * params.x0;
      const y0 = f(params.x0);

      // y = mx + c
      const intercept = y0 - slope * params.x0;

      const slopeStr = slope.toFixed(2);
      const sign = intercept >= 0 ? '+' : '-';
      const interceptStr = Math.abs(intercept).toFixed(2);

      // LaTeX
      funcDisplay.innerHTML = `\\[ f(x) = ${params.a}x^2 \\]`;
      derivDisplay.innerHTML = `\\[ f'(${params.x0}) = ${slopeStr} \\]`;
      tangentEqnDisplay.innerHTML = `\\[ y = ${slopeStr}x ${sign} ${interceptStr} \\]`;

      if (window.MathJax) {
        MathJax.typesetPromise([
          funcDisplay,
          derivDisplay,
          tangentEqnDisplay
        ]).catch(() => {});
      }

      // V·∫Ω parabol
      const positions = curveLine.geometry.attributes.position;
      const range = 15;
      const count = positions.count;

      for (let i = 0; i < count; i++) {
        const x = -range + (i / (count - 1)) * (2 * range);
        const y = f(x);
        positions.setXYZ(i, x, y, 0);
      }
      positions.needsUpdate = true;

      // V·∫Ω ti·∫øp tuy·∫øn
      const xA = params.x0 - 5;
      const yA = slope * (xA - params.x0) + y0;
      const xB = params.x0 + 5;
      const yB = slope * (xB - params.x0) + y0;

      const startVec = new THREE.Vector3(xA, yA, 0);
      const endVec = new THREE.Vector3(xB, yB, 0);
      const mid = new THREE.Vector3()
        .addVectors(startVec, endVec)
        .multiplyScalar(0.5);

      tangentMesh.position.copy(mid);
      tangentMesh.lookAt(endVec);
      tangentMesh.rotateX(Math.PI / 2);

      const len = startVec.distanceTo(endVec);
      tangentMesh.scale.set(1, len, 1);

      // ƒêi·ªÉm ti·∫øp x√∫c
      pointMesh.position.set(params.x0, y0, 0);
    }

    // --- AI & UTILS ---

    async function handleAnalyzeClick() {
      btnAnalyze.disabled = true;
      btnAnalyze.classList.add('opacity-75', 'cursor-wait');
      analyzeIcon.textContent = '‚è≥';

      aiPanel.classList.remove('hidden');
      setTimeout(
        () => aiPanel.classList.remove('translate-x-10', 'opacity-0'),
        10
      );
      aiContent.innerHTML =
        '<div class="text-center py-4 text-gray-400 animate-pulse">ƒêang suy nghƒ©...</div>';

      const f_prime = (2 * params.a * params.x0).toFixed(2);
      const aVal = params.a;
      const xVal = params.x0;

      const prompt = `
B·∫°n l√† m·ªôt gi√°o vi√™n to√°n h·ªçc vui t√≠nh v√† s√¢u s·∫Øc. 
H·ªçc sinh ƒëang xem ƒë·ªì th·ªã h√†m s·ªë $y = ${aVal}x^2$ v√† ti·∫øp tuy·∫øn t·∫°i $x = ${xVal}$.
ƒê·∫°o h√†m (h·ªá s·ªë g√≥c ti·∫øp tuy·∫øn) t√≠nh ƒë∆∞·ª£c l√† $f'(${xVal}) = ${f_prime}$.

H√£y gi·∫£i th√≠ch cho h·ªçc sinh (tr·∫£ l·ªùi ng·∫Øn g·ªçn, d√πng Markdown):
1. **√ù nghƒ©a h√¨nh h·ªçc:** Gi·∫£i th√≠ch t·∫°i sao ti·∫øp tuy·∫øn l·∫°i c√≥ ƒë·ªô d·ªëc l√† $${f_prime}$? (ƒêang l√™n d·ªëc hay xu·ªëng d·ªëc? D·ªëc ƒë·ª©ng hay thoai tho·∫£i?).
2. **Li√™n h·ªá th·ª±c t·∫ø:** V√≠ d·ª• nh∆∞ ƒë√¢y l√† s∆∞·ªùn n√∫i, th√¨ ƒë·ªô d·ªëc n√†y c√≥ √Ω nghƒ©a g√¨ v·ªÅ ƒë·ªô nguy hi·ªÉm? Ho·∫∑c n·∫øu l√† v·∫≠n t·ªëc xe, th√¨ n√≥ ƒëang tƒÉng t·ªëc hay gi·∫£m t·ªëc?

**QUAN TR·ªåNG:** H√£y vi·∫øt t·∫•t c·∫£ c√°c bi·ªÉu th·ª©c to√°n h·ªçc, con s·ªë v√† bi·∫øn s·ªë (x, y, a...) trong d·∫•u LaTeX inline (v√≠ d·ª•: $y = x^2$) ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫πp m·∫Øt.
      `;

      try {
        const response = await callGeminiAPI(prompt);
        aiContent.innerHTML = marked.parse(response);
        if (window.MathJax) {
          MathJax.typesetPromise([aiContent]).catch(err =>
            console.log('MathJax error:', err)
          );
        }
      } catch (e) {
        console.error(e);
        aiContent.innerHTML =
          "<p class='text-red-400'>M·∫•t k·∫øt n·ªëi v·ªõi gia s∆∞ AI. Vui l√≤ng th·ª≠ l·∫°i sau.</p>";
      } finally {
        btnAnalyze.disabled = false;
        btnAnalyze.classList.remove('opacity-75', 'cursor-wait');
        analyzeIcon.textContent = 'üéì';
      }
    }

   async function callGeminiAPI(prompt) {
    const res = await fetch(APPS_SCRIPT_URL, {
        method: "POST",
        // ‚ùå KH√îNG ƒë·∫∑t Content-Type application/json
        // headers: { "Content-Type": "application/json" },

        // G·ª≠i chu·ªói JSON, Apps Script v·∫´n ƒë·ªçc ƒë∆∞·ª£c qua e.postData.contents
        body: JSON.stringify({ prompt })
    });

    if (!res.ok) {
        throw new Error("Network error: " + res.status);
    }

    const data = await res.json();

    if (data.error) {
        throw new Error(data.error);
    }

    return data.text;
}

    function createLabel(text, x, y, z, colorStr) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 64;
      canvas.height = 64;
      ctx.font = 'bold 48px Arial';
      ctx.fillStyle = colorStr;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, 32, 32);

      const texture = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
      sprite.position.set(x, y, z);
      sprite.scale.set(2, 2, 1);
      scene.add(sprite);
    }

    function resetGraph() {
      sliderA.value = 0.5;
      sliderX0.value = 2.0;
      updateGraph();
      controls.reset();
      closeAiPanel();
    }

    function closeAiPanel() {
      aiPanel.classList.add('translate-x-10', 'opacity-0');
      setTimeout(() => aiPanel.classList.add('hidden'), 300);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
