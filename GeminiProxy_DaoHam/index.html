<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Parabol & Đường thẳng (nét đậm)</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body { margin:0; overflow:hidden; background:#111; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    #canvas-container { width:100vw; height:100vh; display:block; }

    .slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:100%; height:6px; background:#4b5563;
      outline:none; border-radius:3px; opacity:0.9;
    }
    .slider-thumb::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:18px; height:18px; background:#3b82f6;
      cursor:pointer; border-radius:50%;
    }

    .math-container{
      background: linear-gradient(180deg, rgba(31,41,55,0.9) 0%, rgba(17,24,39,0.95) 100%);
      border: 1px solid rgba(75,85,99,0.5);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <!-- Control Panel -->
  <div class="absolute top-4 left-4 w-80 bg-gray-900/90 text-white p-6 rounded-xl shadow-2xl backdrop-blur-sm border border-gray-700 z-10 max-h-[90vh] overflow-y-auto">
    <h1 class="text-xl font-bold mb-4 text-blue-400 tracking-tight">Parabol & Đường thẳng</h1>

    <div class="math-container rounded-lg p-4 mb-6">
      <div class="text-gray-400 text-[10px] uppercase tracking-widest font-semibold mb-1">Parabol</div>
      <div id="func-parabola" class="text-lg text-center text-blue-300 min-h-[2rem] flex items-center justify-center">
        \[ y = 0.5x^2 \]
      </div>

      <div class="border-t border-gray-700 my-3"></div>

      <div class="text-gray-400 text-[10px] uppercase tracking-widest font-semibold mb-1">Đường thẳng</div>
      <div id="func-line" class="text-lg text-center text-yellow-300 min-h-[2rem] flex items-center justify-center">
        \[ y = 1.0x + 0.0 \]
      </div>
    </div>

    <!-- a parabola -->
    <div class="mb-4">
      <div class="flex justify-between mb-1">
        <label class="text-sm font-medium text-gray-300">Hệ số \(a\) (parabol)</label>
        <span id="val-a" class="text-sm font-bold text-blue-400">0.5</span>
      </div>
      <input type="range" min="-4" max="4" step="0.1" value="0.5"
        class="slider-thumb" id="slider-a" style="background:#1e3a8a;">
    </div>

    <!-- m line -->
    <div class="mb-4">
      <div class="flex justify-between mb-1">
        <label class="text-sm font-medium text-gray-300">Hệ số \(m\) (đường thẳng)</label>
        <span id="val-m" class="text-sm font-bold text-yellow-300">1.0</span>
      </div>
      <input type="range" min="-5" max="5" step="0.1" value="1.0"
        class="slider-thumb" id="slider-m" style="background:#7c2d12;">
    </div>

    <!-- b line -->
    <div class="mb-6">
      <div class="flex justify-between mb-1">
        <label class="text-sm font-medium text-gray-300">Hệ số \(b\) (đường thẳng)</label>
        <span id="val-b" class="text-sm font-bold text-yellow-300">0.0</span>
      </div>
      <input type="range" min="-5" max="5" step="0.1" value="0.0"
        class="slider-thumb" id="slider-b" style="background:#7c2d12;">
    </div>

    <button id="btn-reset"
      class="w-full py-2 px-4 bg-gray-700 hover:bg-gray-600 text-white rounded transition duration-200 border border-gray-600 text-sm">
      Đặt lại
    </button>
  </div>

  <!-- Canvas -->
  <div id="canvas-container"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls;

    // “Nét đậm thật” bằng Mesh
    let parabolaMesh = null;     // TubeGeometry theo đường cong
    let lineMesh = null;         // Cylinder (đường thẳng)

    const params = { a: 0.5, m: 1.0, b: 0.0 };

    // DOM
    const sliderA = document.getElementById('slider-a');
    const sliderM = document.getElementById('slider-m');
    const sliderB = document.getElementById('slider-b');

    const valA = document.getElementById('val-a');
    const valM = document.getElementById('val-m');
    const valB = document.getElementById('val-b');

    const dispPara = document.getElementById('func-parabola');
    const dispLine = document.getElementById('func-line');

    const btnReset = document.getElementById('btn-reset');

    // Cấu hình vẽ
    const X_MIN = -15, X_MAX = 15;
    const PARABOLA_STEP = 0.2;
    const TUBE_RADIUS = 0.10;      // độ “dày” parabol
    const LINE_RADIUS = 0.10;      // độ “dày” đường thẳng
    const TUBE_SEGMENTS = 250;     // độ mịn ống
    const TUBE_RADIAL = 14;        // độ tròn ống

    init();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111827);
      scene.fog = new THREE.Fog(0x111827, 20, 60);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(15, 15, 25);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.65));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      // Grid
      scene.add(new THREE.GridHelper(40, 40, 0x444444, 0x222222));

      // Axes + labels
      createAxes();

      // Line mesh (cylinder) tạo một lần
      createLineMesh();

      // Events
      window.addEventListener('resize', onWindowResize);
      sliderA.addEventListener('input', update);
      sliderM.addEventListener('input', update);
      sliderB.addEventListener('input', update);
      btnReset.addEventListener('click', reset);

      update();
      animate();
    }

    function createAxes() {
      // Ox
      scene.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-20, 0, 0), new THREE.Vector3(20, 0, 0)]),
        new THREE.LineBasicMaterial({ color: 0xff4444 })
      ));
      // Oy
      scene.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -20, 0), new THREE.Vector3(0, 20, 0)]),
        new THREE.LineBasicMaterial({ color: 0x44ff44 })
      ));

      // Chữ x/y ở chiều dương (đặt hơi nhô lên Z để không “dính” mặt phẳng)
      createLabel("x", 21, 0, 0.6, "#ff4444");
      createLabel("y", 0, 21, 0.6, "#44ff44");
    }

    function createLabel(text, x, y, z, colorStr) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      canvas.width = 256;
      canvas.height = 256;

      ctx.clearRect(0, 0, 256, 256);
      ctx.font = 'bold 160px Arial';
      ctx.fillStyle = colorStr;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, 128, 140);

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;

      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      // Quan trọng: luôn nổi lên, không bị che bởi grid/mesh
      mat.depthTest = false;
      mat.depthWrite = false;

      const sprite = new THREE.Sprite(mat);
      sprite.position.set(x, y, z);
      sprite.scale.set(4.0, 4.0, 1);
      sprite.renderOrder = 999;
      scene.add(sprite);
    }

    function createLineMesh() {
      const geometry = new THREE.CylinderGeometry(LINE_RADIUS, LINE_RADIUS, 1, 18, 1, false);
      const material = new THREE.MeshStandardMaterial({ color: 0xfacc15, metalness: 0.2, roughness: 0.35 });
      lineMesh = new THREE.Mesh(geometry, material);
      scene.add(lineMesh);
    }

    function update() {
      params.a = parseFloat(sliderA.value);
      params.m = parseFloat(sliderM.value);
      params.b = parseFloat(sliderB.value);

      valA.innerText = params.a.toFixed(1);
      valM.innerText = params.m.toFixed(1);
      valB.innerText = params.b.toFixed(1);

      dispPara.innerHTML = `\\[ y = ${params.a.toFixed(1)}x^2 \\]`;
      const sign = params.b >= 0 ? "+" : "-";
      dispLine.innerHTML = `\\[ y = ${params.m.toFixed(1)}x ${sign} ${Math.abs(params.b).toFixed(1)} \\]`;
      if (window.MathJax) MathJax.typesetPromise([dispPara, dispLine]).catch(() => { });

      updateParabolaTube();
      updateStraightLineCylinder();
    }

    function updateParabolaTube() {
      // Tạo danh sách điểm của parabol
      const pts = [];
      for (let x = X_MIN; x <= X_MAX; x += PARABOLA_STEP) {
        pts.push(new THREE.Vector3(x, params.a * x * x, 0));
      }

      const curve = new THREE.CatmullRomCurve3(pts);

      // Tạo Tube mới, bỏ cái cũ để không bị “chồng”
      const newGeo = new THREE.TubeGeometry(curve, TUBE_SEGMENTS, TUBE_RADIUS, TUBE_RADIAL, false);

      if (!parabolaMesh) {
        const mat = new THREE.MeshStandardMaterial({ color: 0x3b82f6, metalness: 0.15, roughness: 0.4 });
        parabolaMesh = new THREE.Mesh(newGeo, mat);
        scene.add(parabolaMesh);
      } else {
        parabolaMesh.geometry.dispose();
        parabolaMesh.geometry = newGeo;
      }
    }

    function updateStraightLineCylinder() {
      const x1 = X_MIN, y1 = params.m * x1 + params.b;
      const x2 = X_MAX, y2 = params.m * x2 + params.b;

      const start = new THREE.Vector3(x1, y1, 0);
      const end   = new THREE.Vector3(x2, y2, 0);

      const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
      lineMesh.position.copy(mid);

      // hướng cylinder theo đoạn thẳng
      lineMesh.lookAt(end);
      lineMesh.rotateX(Math.PI / 2);

      const len = start.distanceTo(end);
      lineMesh.scale.set(1, len, 1);
    }

    function reset() {
      sliderA.value = 0.5;
      sliderM.value = 1.0;
      sliderB.value = 0.0;
      update();
      controls.reset();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
